圣诞节来临了，中圣诞老人准备分发糖果,现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿雪橇最多只能装下重量W的糖果请问圣诞老人最多能带走多大价值的糖果。

解法：
按礼物的价值/重量比从大到小依次选取礼物，对选取的礼物尽可能多地装，直到达到总重量w

证明︰
替换法。对于用非此法选取的最大价值糖果箱序列，可以将其按价值/重量比从大到小排序后得到:
序列1 : a1, a2...
用序列1和按上述解法选取的序列2依次进行比较:序列2∶o1, b2....
价值/重量比相同的若干箱糖果，可以合并成一箱，所以两个序列中元素都不重复对于发现的第一个a; != b;,则必有: a;< b;
则在序列1中，用b这种糖果,替代若干重量的 a这种糖果，则会使得序列1的总价值增加，这和序列1是价值最大的取法矛盾
所以∶序列1=序列2(序列2不可能是序列1的一个前缀且比序列1短)


贪心算法：
每一步行动宗室按某种指标选取最优地操作来进行，该指标只看眼前，冰不考虑以后可能造成的影响。
贪心算法需要证明其正确性
“圣诞老人礼物”题，若糖果只能整箱拿，则贪心法错误


eg.电影节
大学生电影节在北大举办！这天，在北大各地放了多部电影，给定每部电影的放映时间区间，区间重叠的电影不可能同时看（端点可以重合），问李雷最多可以看多少部电影。

贪心解法：将所有电影按结束时间从小到大排序，第一部选结束时间最早的那部电影。然后，每部都选和上一部选中的电影不冲突且结束时间最早的电影。

证明：
替换法。假设用贪心法台哦选的电影序列为：a1,a2,...
不用此法挑选的最长的电影序列为：b1,b2,...
现在可以证明，对任意i，bi均可以替换成ai

用S(x)表示x开始时间，E(x)表示x结束时间，则:1) b1可以替换成a1，因为E(a1)<=E(b1)
2)若可以找到a满足E(a;)<= E(b)且a;可以替换b;，则存在E(ai+1)<=E(bi+1)且ai+1可以替换bi+1
证∶
因为E(ai)<= E(bi)且E(bi)<= S(bi+1)则:E(ai)<= S(bi+1)
则：E(ai) <= S(bi+1)
ai+1是所有S(x)>=E(ai)的x中，E(x)最小的S(bi+1)>=E(bi)>=E(ai)，所以E(bi+1)>= E(ai+1)因此用ai+1替换bi+1不会对后续造成影响，替换可行

eg.奶牛挤奶
有n头牛( 1<=n<=50,000)要挤奶。给定每头牛挤奶的时间区间[A,B] (1<=A<=B<=1,000,000，A,B为整数)。牛需要呆畜栏里才能挤奶。一个畜栏同一时间只能容纳一头牛。问至少需要多少个畜栏，才能完成全部挤奶工作，以及每头牛都放哪个畜栏里( Special judged)去同一个畜栏的两头牛，它们挤奶时间区间哪怕只在端点重合也是不可以的。

贪心解法︰
所有奶牛都必须挤奶。到了一个奶牛的挤奶开始时间，就必须为这个奶牛找畜栏。因此按照奶牛的开始时间逐个处理它们，是必然的。
S(x)表示奶牛x的开始时间。E(x)表示x的结束时间。对E(x),x可以是奶牛，也可以是畜栏。畜栏的结束时间，就是正在其里面挤奶的奶牛的结束时间。同一个畜栏的结束时间是不断在变的。

1)把所有奶牛按开始时间从小到大排序。
2)为第一头奶牛分配一个畜栏。
3)依次处理后面每头奶牛i。处理i时，考虑已分配畜栏中，结束时间最早的畜栏x。
若E(x)< S(i)，则不用分配新畜栏，i可进入x,并修改E(x)为E(i)若E(x) >= S(i)，则分配新畜栏y,记 E(y) = E(i)
直到所有奶牛处理结束
需要用优先队列存放已经分配的畜栏，并使得结束时间最早的畜栏始终位于队列头部。

using namespace std;
struct cow {
	int a ,b; //挤奶区间起终点
	int No ; //编号
	bool operator<(const cow & c) const {
		return a < c.a ;
}
cows [50100];
int pos[50100] ; //pos [i]表示编号为i的奶牛去的畜栏编号
struct stall{
struct stall{
	int end;//结束时间
	int No;//编号
	bool operator<(const stall &s)const
		return end > s. end;
	}
	stal1 (int e ,int n) : end (e) ,No (n) { }
};
int main (){
	int n ;
	scanf ("8d" , &n) ;
	for(int i = 0 ;i < n ; ++i){
		scanf ( "%d%d" , &cows [i].a , &cows[i].b)
		cows[i].No = i;
	}
	sort (cows , cows+n);
	int total =0 ;
	priority_queue<stall> pq;
	for (int i = 0;i <n; ++i){
		if(pq. empty () ) {
			++total;
			pq.push (stall (cows[i].b,total));pos [cows [i].No]= total;
		}
		else {
				stall st = pq.top () ;
				if( st.end < cows[i].a ) { //端点也不能重合
				pq.pop () ;
				pos[cows [i].No]= st.No ;
				pq.push (stall (cows [i].b,st.No) ) ;
				}
		else { //对应if( st.end < cows [i].a)
			++total;
			pq.push (stall{ cows[i].b,total} );
			pos [cows[i].No]= total ;
			}
		}
	}
	printf("%d\n" ,total) ;for(int i = 0;i <n ;++i)
	printf ( "8d\n" ,pos[i] );
	return 0 ;
}
