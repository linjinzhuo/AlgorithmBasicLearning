农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点N(O<=N<=100000)，牛位于点K(o<=K<=1ooooo)。农夫有两种移动方式:
1、从X移动到X-1或X+1，每次移动花费一分钟
2、从X移动到2*X，每次移动花费一分钟。
假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛?


假设农夫起始位于点3，牛位于5，N=3，K=5，最右边是6.如何搜索到一跳走到5的路径？
int N,K;
const int MAXN = 100000;
int N,K;
const int MAXN = 100000;
int visited[MAXN+10];//判重标记,visited[i]= true表示i已经扩展过
struct Step{
	int x;//位置
	int steps;//到达x所需的步数Step(int xx,int s):x(xx),steps(s){}
};
queue<Step> q;//队列,即Open表
int main() i
	cin >>N>>K;
	memset(visited,0,sizeof(visited));q.push(Step(N,0));
	visitedINI=1:
	while(!q.empty)){
		Step s= q.front();
		if( s.x == K){//找到目标
			cout << s.steps <<endl;
			return 0;
		}
		else {
			if( s.x- 1 >= 0 && !visited[s.x-1]){
				q.push(Step(s.x-1,s.steps+1));visited[s.x-1]= 1;
			}
			if(s.x+ 1<= MAXN && !visited[s.x+1]){
				q.push(Step(s.x+1,s.steps+1));visited[s.x+1]=1;
			}
			if( s.x* 2)<= MAXN &&!visited[s.x*2] ){
				q.push(Step(s.x*2,s.steps+1));visited[s.x*2]=1;
			}
			q.pop();
		}
	}
	return 0;
}


定义一个矩阵:
0 1 0 0 0
0 1 0 1 0
0 0 o o 0
0 1 1 1 0
0 0 0 1 0
它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，
只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。

基础广搜。先将起始位置加入队列

每次从队列拿出一个元素，扩展其相邻的四个元素入队列（要判重）
直到队头元素为终点为止。队列里的元素记录了指向父节点（上一步）的指针
队列元素：
struct{
	int r,c;
	int f;//父节点在队列中的下标
}

队列不能用stl的queue或者deque，要自己写。用一个一维数组实现，需要维护一个头指针和尾指针


八数码

八数码问题是人工智能中的经典问题
有一个3*3的棋盘，其中有0-8共9个数字，0表示空格，其他的数字可以和0交换位置。求由初始状态到达目标状态：
1 2 3
4 5 6
7 8 0
的步数最少的解
8 2 3       
1 4 6
5 7 0 

广度优先搜索，优先扩展浅层节点（状态），逐渐深入.
用队列保存待扩展的节点
从队首取出节点，扩展出的新节点放入队尾，直到队首出现目标节点（问题的解）

用合理的编码表示“状态”，减小存储代价

方案一：
1.每个状态对应于一个9位数，则该九位数最大为876543210，小于2^31，则int就能表示一个状态。
2.判重需要一个标志位序列，每个状态对应于标志位序列中的1位，标志位为0表示该状态尚未扩展，为1则说明已经扩展过了。
3.标志位序列可用字符数组a存放。a的每个元素存放8个状态的标志位。最多需要87654321位，因此a数组需要876543210/8 + 1个元素，即109567902字节。
4.如果某个状态对应于数x，则其标志位就是a[x/8]的第x%8位
5.空间要求还是太大。


方案二：
1.把每个状态都看做‘0’-‘8’的一个排列，以此排雷全部排列中的位置作为其序号。状态用其排列的序号来表示 
2.012345678是第0个排列，876543210是第9！-1个
3.状态总数即排列总数：9！=362880
判重用的标志数组a只需要362880bit即可。
4.如果某个状态的序号是x，则其标志位就是a[x/8]的第x%8位
5.在进行状态间转移，即一个状态通过某个移动变化到另一个状态时，需要先把int的状态（排列序号），转变为字符串形式的状态，然后再字符串形式的状态上进行移动，得到字符串形式的新状态，再把新状态转换成int形式（排列序号）
6.需要根据序号判断状态和根据状态找序号的函数

方案三：
1.还是把一个状态看作一个数的10进制表示形式
2.用set<int>进行判重。每入队一个状态就将其加到set里，判重时，查找该set，看能否找到状态


广搜一般用于状态表示比较简单、求最优策略的问题
优点:是一种完备策略，即只要问题有解，它就一定可以找到解。并且，广度优先搜索找到的解，还一定是路径最短的解。
缺点:盲目性较大，尤其是当目标节点距初始节点较远时，将产生许多无用的节点，因此其搜索效率较低。需要保存所有扩展出的状态，占用的空间大
深搜几乎可以用于任何问题
·只需要保存从起始状态到当前状态路径上的节点
根据题目要求凭借自己的经验和对两个搜索的熟练程度做出选择
