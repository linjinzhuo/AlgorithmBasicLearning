农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点N(O<=N<=100000)，牛位于点K(o<=K<=1ooooo)。农夫有两种移动方式:
1、从X移动到X-1或X+1，每次移动花费一分钟
2、从X移动到2*X，每次移动花费一分钟。
假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛?


假设农夫起始位于点3，牛位于5，N=3，K=5，最右边是6.如何搜索到一跳走到5的路径？
int N,K;
const int MAXN = 100000;
int N,K;
const int MAXN = 100000;
int visited[MAXN+10];//判重标记,visited[i]= true表示i已经扩展过
struct Step{
	int x;//位置
	int steps;//到达x所需的步数Step(int xx,int s):x(xx),steps(s){}
};
queue<Step> q;//队列,即Open表
int main() i
	cin >>N>>K;
	memset(visited,0,sizeof(visited));q.push(Step(N,0));
	visitedINI=1:
	while(!q.empty)){
		Step s= q.front();
		if( s.x == K){//找到目标
			cout << s.steps <<endl;
			return 0;
		}
		else {
			if( s.x- 1 >= 0 && !visited[s.x-1]){
				q.push(Step(s.x-1,s.steps+1));visited[s.x-1]= 1;
			}
			if(s.x+ 1<= MAXN && !visited[s.x+1]){
				q.push(Step(s.x+1,s.steps+1));visited[s.x+1]=1;
			}
			if( s.x* 2)<= MAXN &&!visited[s.x*2] ){
				q.push(Step(s.x*2,s.steps+1));visited[s.x*2]=1;
			}
			q.pop();
		}
	}
	return 0;
}


定义一个矩阵:
0 1 0 0 0
0 1 0 1 0
0 0 o o 0
0 1 1 1 0
0 0 0 1 0
它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，
只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。

基础广搜。先将起始位置加入队列

每次从队列拿出一个元素，扩展其相邻的四个元素入队列（要判重）
直到队头元素为终点为止。队列里的元素记录了指向父节点（上一步）的指针
队列元素：
struct{
	int r,c;
	int f;//父节点在队列中的下标
}

队列不能用stl的queue或者deque，要自己写。用一个一维数组实现，需要维护一个头指针和尾指针
