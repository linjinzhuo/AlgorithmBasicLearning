例题1.数字三角形
		7
	  3   8
	8   1   0
  2   7   4   4
4   5   2   6   5
在上面的数字三角形中寻找一条从顶部岛底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或者右下走。只需要求出这个最大和即可，无需给出具体路径，三角形的行数大于1小于等于100，数字为0-99

用二维数组存放数字三角形
D(r,j):第r行第j个数字(r,j从1开始算)
MaxSum(r,j):c从D(r,j)到底边的各条路径中，最佳路径的数字之和。
求MaxSum(1,1)

典型的递归问题
时间复杂度巨大达到2^n!!!

改进：如果每算出一个MaxSum(r,j)就保存起来，下次用到其值的时候直接取用，则可以免去重复计算。那么可以用o(n^2)时间完成计算。因为三角形的数字总数是n(n+1)/2
#include <iostream>
#include <algorithm>
#define MAX 101
using namespace std;
int D[MAX][MAX];
int maxsum[MAX][MAX];
int n;
int MaxSum(int i,int j){
	if(maxsum[i][j] != -1){//ij到底边最大和被算出来过
		rerturn maxsum[i][j];
	}
	if(i == n){
		return D[i][j];
	}else{
		int x = MaxSum(i+1,j);
		int y = MaxSum(i+1,j+1);
		maxum[i][j] = max(x,y) + D[i][j];
	}
	return maxsum[i][j];
}
int main(){
	int i,j;
	cin>>n;
	for(i = 1;i <= n;i++){
		for(j = 1;j <= i;j++){
			cin>>D[i][j];
			masSum[i][j] = -1;//初始化为-1意为到这个点的值还没有被算出来过
		}
	}
	cout << MaxSum(1,1) << endl;
}


递归转成递推
由下往上
		30
	  23  21
	20  13  10
  7   12  10  10
4   5   2   6    5       
#define MAX 101
int D[MAX][MAX];
int n; 
int maxsum[MAX][MAX];
int main(){
	int i,j;
	cin>>n;
	for(i = 1;i <= n;i++){
		for(j = 1;j <= i;j++){
			cin>>D[i][j];
		}
	}
	for(int i = 1;i <= n;++i){
		maxsum[n][i] = D[n][i];
	}
	for(int i = n-1;i >= 1;i--){
		for(int j = 1;j <= i;++j){
			maxsum[i][j] = max(maxsum[i+1][j],maxsum[i+1][j+1] + D[i][j]);
		}
	}
	cout << maxsum[1][1] << endl;
}

空间优化：
进一步考虑，连maxsum数组都可以不要，直接用D的第n行代替maxsum即可


动态规划解题一般思路
1.将原问题分解成为子问题
把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决。
子问题的解一旦求出就会被保存，所以每个子问题只需求解一次。
2.确定状态
在动态规划中，往往将和子问题相关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题，所谓某个“状态”下的值，就是这个“状态”所对应的子问题的解。
3.确定一些初始状态（边界状态）的值
以数字三角形为例，初始状态就是底边数字，值就是底边数字的值。
4.确定状态转移方程
定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移————即如何从一个或多个“值”已知的“状态”，求出另一个“状态”的值。状态的迁移可以用递推公式表示，此递推公式也可以称为“状态转移方程”。
数字三角形的状态转移方程：
MaxSum[r][j] = D[r][j]    r = N
			 = Max(MaxSum[r+1][j],MaxSum[r+1][j+1]+D[r][j])   其他情况


能用动规解决的问题的特点
1.问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。
2.无后效性。当前的若干个状态值一旦确定，啧此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种 手段或经过哪条路径演变到当前的这若干个状态，没有关系。


eg.最长上升子序列
一个数的序列ai，当a1<a2<...<as的时候，我们称这个序列是上升的。对于给定的一个序列(a1,a2,...,aN)，我们可以得到一些上升的子序列(ai1,ai2,...,aik),这里1<=i1<i2<ik<=N.比如，对于序列(1,7,3,5,9,4,8),有它的一些上升子序列，如(1,7),(3,4,8)等等。这些子序列中最长的长度是4，比如子序列(1,3,5,8) 。

1.子问题：
“求以ak(k = 1,2,3...n)为终点的最长上升子序列的长度”一个上升子序列中最右边的那个数，称为该子序列的“终点”
2.确定状态：
子问题只和一个变量--数字的位置相关。因此序列中数的位置k就是“状态”，而状态k对应的“值”，就是以ak作为“终点”的最长上升子序列的长度。状态一共有n个
3.找出状态转移方程
maxLen(k)表示以ak作为终点的最长上升子序列的长度那么：
初始状态：maxLen(1) = 1 maxLen(k) = max {maxLen(i):1<=i<k且ai < ak 且k≠1} + 1，maxLen(k)的值，就是在ak左边，终点数值小于ak，且长度最大的那个上升子序列的长度再加1.因为ak左边任何“终点”小于ak的子序列，加上ak后就能形成一个更长的上升子序列。
const int MAXN = 1010;
int a[MAXN];
int maxLen[MAXN];
int main(){
	int N;
	cin>>N;
	for(int i = 1;i <= N;++i){
		cin>>a[i];
		maxLen[i] = 1;
	}
	for(int i = 2;i <= N;++i){
		//每次求以第i个数为终点的最长上升子序列的长度
		for(int j = 1;j < i;++j){
			//查看以第j个数为终点的最长上升子序列
			if(a[i] > a[j])
				maxLen[i] = max{maxLen[i],maxLen[j]+1}
		}
	}
	cout<<*max_element{maxLen+1,maxLen + N +1};
	return 0;
}//时间复杂度o(n^2)



动态规划常用的两种形式
1.递归型：
	优点：直观，容易编写
	缺点：可能会因递归层数太深导致爆栈，函数调用带来额外时间开销。无法使用滚动数组节省空间。总体来说，比递推型慢。
2.递推型：
	效率高，有可能使用滚动数组节省时间。

最长公共子序列
	给出两个字符串，求出这样的一个最长的公共子序列的长度：子序列中的每个字符都能在两个原串中找到，且每个字符的先后顺序和原串中的先后顺序一致。

显然：
	MaxLen(n,0) = 0(n = 0,...,len1)
	MaxLen(0,m) = 0(m = 0,...,len2)
递推公式：
if(s1[i-1] == s2[j-1])//s1的最左边字符是s1[0]
	MaxLen(i,j) = MaxLen(i-1,j-1) + 1;
else
	MaxLen(i,j) = Max(MaxLen(i,j-1),MaxLen(i-1,j));


#include<iostream>
#include<cstring>
using namespace std;
char szl[1000];
char sz2[1000];
int maxLen[1000][1000];
int main(){
	while(cin >> szl >>sz2){
		int length1 = strlen(sz1);
		int length2 = strlen(sz2);
		int nTmp;
		int i,j;
		for(i = 0;i <= length1;i++){
			maxLen[i][0] = 0;
		}
		for(j = 0;j <= length2;j++){
			maxLen[0][j] = 0;
		}
		for(i = 1;j <= length1;i++){
			for(j = 1;j <= length2;j++){
				if(sz1[i-1] == sz2[j-1]){
					maxLen[i][j] = maxLen[i-1][j-1] + 1;
				}else{
					maxLen[i][j] = max(maxLen[i][j-1],maxLen[i-1][j]);
				}
			}
		}
		cout<< maxLen[length1][length2]<<end1;
	}
	return 0;
}



eg.最佳加法表达式
有一个由1...9组成的数字串。问如果将m个加号插入到这个数字串中，在各种可能形成的表达式中，值最小的那个表达式的值是多少。

解题思路
假定数字串长度为n，添加完加号后，表达式的最后一个加号添加在第i个数字后面，那么整个表达式的最小值，就等于在前i个数字中插入m-1个加号所能形成的最小值，加上第i+1到第n个数字所组成的数的值（i从1开始算）

设v(m.n)表示在n个数字中插入m个加号所能形成的表达式最小值，那么：
if m = 0
	V(m,n) = n个数字构成的整数
else if n < m + 1
	V(m,n) = ∞
else 
	V(m,n) = Min{V(m-1,i)+Num(i+1,n)} (i = m...n-1)

Num(i,j)表示从第i个数字到第j个数字所组成的数。数字编号从1开始算。此操作复杂度为o(j-i+1),可以预处理后存起来。
总时间复杂度为o(mn^2)




eg.Help Jimmy
场景中包括多个长度和高度各不相同的平台。
地面是最低的平台，高度为0，长度无限。
Jimmy从时刻0在高度高于所有平台的某处开始下落，它的下落速度始终为1m/s。当Jimmy落到某个平台时，游戏者选择它向左还是向右跑，它跑动的速度也是1m/s。当Jimmy跑到平台边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏结束
设计一个程序，计算Jimmy到地面时可能的最早时间。

不妨认为Jimmy开始的位置是一个编号为0，长度为0的板子，假设LeftMinTime(k)表示从k号板子左端到地面的最短时间，RightMinTime(k)表示从k号板子右端到地面的最短时间，那么，求板子k左端点到地面的最短时间方法如下：

if(板子k左端正下方没有别的板子){
	if(板子k的高度h(k)大于MAX)
		LeftMinTime(k) = ∞
	else
		LeftMinTime(k) = h(k);
}
else if(板子k左端正下方的板子编号为m)
	LeftMinTime(k) = h(k)-h(m)+Min(LeftMinTime(m) + Lx(k)-lx(m),
	RightMinTime(m)+Rx(m)-lx(k));           
上面，hi就代表i号板子的高度，lxi就代表i号板子左端点的横坐标，rxi就代表i号板子右端点的横坐标。那么hk-hm当然是从k号板子跳到m号板子所需要的时间，lxk-lxm就是从m号板子的落脚点走到m号板子左端点的时间，pxm-lxk就是从m号板子的落脚带你走到右端点所需的时间。
求RightMinTime(k)的过程类似。

时间复杂度：
一共n个板子，每个左右两端的最小时间各算一次o(n)
找到板子一段到地面之间有那块板子，需要遍历板子o(n)
总时间复杂度为o(n^2)
