二分查找函数：
写一个函数BinarySearch,在包含size个元素的、从小到大排序的int数组a里查找元素p，如果找到，则返回元素下标，如果找不到，则返回-1，要求复杂度O(logn)
int BinarySearch(int a[],int size,int p){
	int L = 0;//查找区间左端点
	int R = size -1;//查找区间的右端点
	while(L <= R){
		int mid = L+(R+L)/2;//取查找区间正中元素的下标
		if(p == a[mid]){
			return mid;
		}else if(p > a[mid]){
			L = mid + 1;//设置新的查找区间的左端点
		}else{
			R = mid - 1;//设置新的查找区间的右端点
		}
	}
	return -1;
}//复杂度o(log(n))

写一个函数LowpowerBound，在包含size个元素的、从小到大排序的int数组a里查找比给定整数p小的，下标最大的元素。找到则返回其下标，找不到则返回-1
int LowpowerBound(int a[],int size,int p)//复杂度o(logn){
	int L = 0;//查找区间的左端点
	int R = size - 1；//查找区间的右端点
	int lastPos = -1；//到目前为止找到的最优解
	while(L <= R){
		int mid = L+(R-L)/2;//取查找区间正中元素的下标
		if(a[mid] >= p){
			R = mid - 1;
		}else{
			lastPos = mid;
			L = mid + 1;
		}
	}
	return lastPos;
}


二分法求方程的根
求下面方程的一个根：f(x)=x^3-5x^2+10x-80=0若求出的根是a，则要求|f(a)|<=10^-6
(在定义区间上为单调函数)
double EPS = 1E-6;
double f(double x){
	return x*x*x -5*x*x +10*x - 80;
}
int main(){
	double root, x1 = 0,x2 = 100,y;
	root = x1+(x2-x1)/2;
	int triedTimes = 1;//记录一共尝试多少次
	y = f(root);
	while(fabs(y) >EPS){
		if(y > 0) x2 = root;
		else 	  x1 = root;
		root = x1+(x2 -x1)/2;
		y = f(root);
		triedTime++;
	}
	printf("%.0f\n",root);
	printf("%d",triedTime);
	return 0;
}
